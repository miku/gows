# Object Oriented Programming

> [https://go.dev/doc/faq#Is_Go_an_object-oriented_language](https://go.dev/doc/faq#Is_Go_an_object-oriented_language)

> Yes and no. Although Go has types and methods and allows an object-oriented
> style of programming, there is no type hierarchy. The concept of “interface”
> in Go provides a different approach that we believe is easy to use and in some
> ways more general.

> There are also ways to embed types in other types to provide something
> analogous—but not identical—to subclassing. Moreover, methods in Go are more
> general than in C++ or Java: they can be defined for any sort of data, even
> built-in types such as plain, “unboxed” integers. They are not restricted to
> structs (classes). 

## Contructors

[Does Go support function overloading?](https://stackoverflow.com/questions/6986944/does-the-go-language-have-function-method-overloading)

> No it does not.

When faced with the decision of providing a constructor for a type, these are
the most common approaches - using a hypothetical `Store` implemented in a package
`store`:

### Constructor variants

* store.New(...) Store
* store.New(...) (Store, error)
* store.NewStore(...) (Store, error) 
* store.NewCapacity(...) ...
* store.NewCapacityTimeout(...) ...

This is fine for simple case, few variants, but unwieldy for many options.

### Using separate options

Define a separate `Opts` struct with the options you want to pass to the
constructor.

* store.New(opts Opts) (Store, error)

In the wild:

* [https://github.com/syndtr/goleveldb#usage](https://github.com/syndtr/goleveldb#usage)

### Functional Options Pattern

* Example: [x/constructors/main.go](x/constructors/main.go)

More: [https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)

## Composition over inheritance

> The bigger the interface, the weaker the abstraction.

